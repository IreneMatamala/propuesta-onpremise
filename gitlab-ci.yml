# Pipeline completo para Microservicios

variables:
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""
  DOCKER_DRIVER: overlay2

stages:
  - build
  - test
  - security
  - package
  - deploy-dev
  - deploy-qa
  - deploy-staging
  - deploy-prod
  - monitor

# Jobs comunes
.build-template: &build_template
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - export DOCKER_BUILDKIT=1
    - docker build --build-arg BUILDKIT_INLINE_CACHE=1 --cache-from $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
  artifacts:
    paths:
      - docker-image.txt
    expire_in: 1 week

.test-template: &test_template
  stage: test
  image: python:3.9-slim
  before_script:
    - pip install -r requirements.txt
  script:
    - python -m pytest --cov=app --cov-report=xml --cov-report=html
    - python -m flake8 app/
    - python -m black --check app/
  artifacts:
    paths:
      - coverage/
    reports:
      junit: junit.xml
      cobertura: coverage.xml

.security-template: &security_template
  stage: security
  image: aquasec/trivy:latest
  script:
    - trivy image --exit-code 1 --severity HIGH,CRITICAL $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - trivy fs --exit-code 1 --severity HIGH,CRITICAL .
  artifacts:
    paths:
      - gl-sast-report.json
    reports:
      sast: gl-sast-report.json

# Jobs específicos para cada microservicio
build-microservice-a:
  <<: *build_template
  variables:
    CI_REGISTRY_IMAGE: $CI_REGISTRY/microservice-a
  only:
    refs:
      - develop
      - main
      - merge_requests
    changes:
      - src/microservice-a/**/*
      - charts/microservice-a/**/*

test-microservice-a:
  <<: *test_template
  dependencies:
    - build-microservice-a
  script:
    - cd src/microservice-a
    - pip install -r requirements.txt
    - python -m pytest tests/ --junitxml=test-results.xml
    - python -m coverage run -m pytest tests/
    - python -m coverage xml
  artifacts:
    paths:
      - src/microservice-a/coverage.xml
      - src/microservice-a/test-results.xml
    reports:
      junit: src/microservice-a/test-results.xml
      cobertura: src/microservice-a/coverage.xml

security-microservice-a:
  <<: *security_template
  variables:
    CI_REGISTRY_IMAGE: $CI_REGISTRY/microservice-a
  dependencies:
    - build-microservice-a

sonarqube-check:
  stage: security
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  script:
    - sonar-scanner
      -Dsonar.projectKey=microservice-a
      -Dsonar.sources=src/microservice-a
      -Dsonar.host.url=${SONARQUBE_URL}
      -Dsonar.login=${SONARQUBE_TOKEN}
      -Dsonar.projectVersion=${CI_COMMIT_SHA}
  allow_failure: true
  only:
    - develop
    - main
    - merge_requests

# Jobs para microservicio B (similar estructura)
build-microservice-b:
  <<: *build_template
  variables:
    CI_REGISTRY_IMAGE: $CI_REGISTRY/microservice-b
  only:
    refs:
      - develop
      - main
      - merge_requests
    changes:
      - src/microservice-b/**/*
      - charts/microservice-b/**/*

# Deployment jobs
deploy-dev:
  stage: deploy-dev
  image: alpine/helm:3.12.3
  script:
    - apk add --no-cache git curl
    - helm repo add stable https://charts.helm.sh/stable
    - helm upgrade --install microservice-a charts/microservice-a/ -f charts/microservice-a/values-dev.yaml --namespace dev --create-namespace --wait
    - helm upgrade --install microservice-b charts/microservice-b/ -f charts/microservice-b/values-dev.yaml --namespace dev --wait
  environment:
    name: dev
    url: https://dev.example.com
  only:
    - develop

deploy-qa:
  stage: deploy-qa
  image: alpine/helm:3.12.3
  script:
    - helm upgrade --install microservice-a charts/microservice-a/ -f charts/microservice-a/values-qa.yaml --namespace qa --create-namespace --wait
    - kubectl rollout status deployment/microservice-a -n qa --timeout=300s
  environment:
    name: qa
    url: https://qa.example.com
  only:
    - develop
  when: manual

deploy-staging:
  stage: deploy-staging
  image: alpine/helm:3.12.3
  script:
    # Backup antes del despliegue
    - ./tools/backup/backup-pre-deploy.sh staging
    - helm upgrade --install microservice-a charts/microservice-a/ -f charts/microservice-a/values-staging.yaml --namespace staging --wait
    # Health check
    - ./tools/monitoring/health-check.py --namespace staging --timeout 300
  environment:
    name: staging
    url: https://staging.example.com
  only:
    - main
  when: manual

deploy-production:
  stage: deploy-prod
  image: alpine/helm:3.12.3
  script:
    # Backup crítico
    - ./tools/backup/backup-pre-deploy.sh production
    # Deploy con estrategia blue-green
    - ./scripts/blue-green-deploy.sh microservice-a production
    # Verificación post-deploy
    - ./tools/monitoring/smoke-tests.py --environment production
  environment:
    name: production
    url: https://app.example.com
  only:
    - main
  when: manual
  dependencies: []

# Rollback job
rollback-production:
  stage: deploy-prod
  image: alpine/helm:3.12.3
  script:
    - helm rollback microservice-a $(($(helm history microservice-a -n production --output json | jq '.[0].revision' | tr -d '"') - 1)) -n production
    - ./tools/notify-slack.py --channel production-alerts --message "Rollback ejecutado para microservice-a"
  when: manual
  allow_failure: false
  only:
    - main

# Monitoreo
prometheus-alerts:
  stage: monitor
  image: curlimages/curl:latest
  script:
    - curl -X POST ${PROMETHEUS_WEBHOOK_URL} -d '{"status": "firing", "alerts": [{"status": "firing", "labels": {"alertname": "DeploymentSuccess", "job": "gitlab-ci"}}]}'
  only:
    - main
